# XCode 数据权限开发手册

XCode 数据权限模块提供行级数据访问控制能力，支持按用户、部门过滤数据，实现"仅本人"、"本部门"、"本部门及下级"等常见数据权限场景。

## 目录

- [概述](#概述)
- [核心概念](#核心概念)
- [快速入门](#快速入门)
- [接口说明](#接口说明)
- [上下文管理](#上下文管理)
- [数据过滤](#数据过滤)
- [增删改校验](#增删改校验)
- [敏感字段遮蔽](#敏感字段遮蔽)
- [高级用法](#高级用法)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 概述

### 什么是数据权限

数据权限（Data Scope）是指控制用户可以访问哪些数据行的权限。与功能权限（控制用户能执行什么操作）不同，数据权限控制的是操作的数据范围。

例如：
- 销售人员只能看到自己的订单
- 部门经理可以看到本部门所有员工的数据
- 总经理可以看到所有部门的数据

### 支持的数据范围

| 范围 | 枚举值 | 说明 |
|------|--------|------|
| 全部 | `DataScopes.全部` (0) | 不受数据权限约束，可访问所有数据 |
| 本部门及下级 | `DataScopes.本部门及下级` (1) | 可访问用户所在部门及所有下级部门的数据 |
| 本部门 | `DataScopes.本部门` (2) | 仅可访问用户所在部门的数据 |
| 仅本人 | `DataScopes.仅本人` (3) | 仅可访问用户自己创建的数据 |
| 自定义 | `DataScopes.自定义` (4) | 根据角色配置的部门列表过滤 |

### 设计原则

1. **非侵入式**：通过接口和模块机制，对现有代码改动最小
2. **灵活配置**：数据范围在角色上配置，支持多角色权限合并
3. **自动处理**：查询自动过滤、新增自动设置、修改删除自动校验
4. **可扩展**：支持自定义字段名、自定义过滤逻辑

---

## 核心概念

### 接口体系

```
IUserScope          - 仅用户标识，适用于个人数据
     ↓
IDataScope          - 完整数据权限，包含用户和部门标识
     ↑
IDepartmentScope    - 仅部门标识，适用于部门数据

IDataScopeFieldProvider - 自定义字段名提供者
IFieldScope            - 敏感字段控制
```

### 核心组件

| 组件 | 职责 |
|------|------|
| `DataScopeContext` | 存储当前用户的数据权限上下文 |
| `DataScopeInterceptor` | 实体拦截器，处理增删改查时的权限校验 |
| `DataScopeHelper` | 辅助类，提供过滤表达式和权限判断方法 |
| `FieldScopeHelper` | 敏感字段遮蔽辅助类 |

---

## 快速入门

### 第一步：实体类实现接口


根据业务需求选择合适的接口：

```csharp
// 场景1：个人数据（如个人笔记、收藏）
public partial class Note : Entity<Note>, IUserScope
{
    public Int32 UserId { get; set; }
}

// 场景2：部门数据（如部门公告）
public partial class Announcement : Entity<Announcement>, IDepartmentScope
{
    public Int32 DepartmentId { get; set; }
}

// 场景3：完整数据权限（如订单、工单）
public partial class Order : Entity<Order>, IDataScope
{
    public Int32 UserId { get; set; }
    public Int32 DepartmentId { get; set; }
}
```

### 第二步：注册数据权限拦截器

在实体类的静态构造函数中注册：

```csharp
public partial class Order : Entity<Order>, IDataScope
{
    static Order()
    {
        // 注册数据权限拦截器
        Meta.Interceptors.Add<DataScopeInterceptor>();
    }
}
```

### 第三步：设置数据权限上下文

在请求开始时设置当前用户的数据权限上下文：

```csharp
// ASP.NET Core 中间件示例
public class DataScopeMiddleware
{
    public async Task InvokeAsync(HttpContext context, IManageProvider provider)
    {
        var user = provider.Current as IUser;
        if (user != null)
        {
            // 从用户创建数据权限上下文
            DataScopeContext.Current = DataScopeContext.Create(user);
        }
        
        try
        {
            await _next(context);
        }
        finally
        {
            DataScopeContext.Current = null;
        }
    }
}
```

### 第四步：查询时应用数据权限

在 Search 方法中应用数据权限过滤：

```csharp
public static IList<Order> Search(Int32 status, PageParameter page)
{
    var exp = new WhereExpression();
    if (status >= 0) exp &= _.Status == status;
    
    // 应用数据权限过滤
    exp = exp.ApplyDataScope<Order>();
    
    return FindAll(exp, page);
}
```

---

## 接口说明

### IUserScope

仅包含用户标识的数据权限接口，适用于个人数据。

```csharp
public interface IUserScope
{
    /// <summary>用户。数据权限过滤时使用</summary>
    Int32 UserId { get; set; }
}
```

**适用场景**：
- 个人笔记、收藏
- 用户设置、偏好
- 个人消息、通知

### IDepartmentScope

仅包含部门标识的数据权限接口，适用于部门级数据。

```csharp
public interface IDepartmentScope
{
    /// <summary>部门编号。数据权限过滤时使用</summary>
    Int32 DepartmentId { get; set; }
}
```

**适用场景**：
- 部门公告、通知
- 部门文档、资料
- 部门统计数据

### IDataScope

完整的数据权限接口，继承 IUserScope 和 IDepartmentScope。

```csharp
public interface IDataScope : IUserScope, IDepartmentScope { }
```

**适用场景**：
- 订单、工单
- 客户、商机
- 任务、项目

**权限控制逻辑**：
- `仅本人`：使用 UserId 过滤
- `本部门/本部门及下级/自定义`：使用 DepartmentId 过滤

### IDataScopeFieldProvider

当实体的字段名不是标准的 UserId/DepartmentId 时，实现此接口指定实际字段：

```csharp
public interface IDataScopeFieldProvider
{
    /// <summary>获取用户字段。返回 null 表示使用默认的 UserId</summary>
    FieldItem? GetUserField();

    /// <summary>获取部门字段。返回 null 表示使用默认的 DepartmentId</summary>
    FieldItem? GetDepartmentField();

    /// <summary>获取租户字段。返回 null 表示使用默认的 TenantId</summary>
    FieldItem? GetTenantField();
}
```

**使用示例**：

```csharp
public partial class Order : Entity<Order>, IDataScope, IDataScopeFieldProvider
{
    // 实际字段名是 CreatorId 和 OrgId
    public Int32 CreatorId { get; set; }
    public Int32 OrgId { get; set; }
    
    // IDataScope 显式实现
    Int32 IUserScope.UserId { get => CreatorId; set => CreatorId = value; }
    Int32 IDepartmentScope.DepartmentId { get => OrgId; set => OrgId = value; }
    
    // IDataScopeFieldProvider 实现
    public FieldItem? GetUserField() => _.CreatorId;
    public FieldItem? GetDepartmentField() => _.OrgId;
    public FieldItem? GetTenantField() => null;
}
```

### IFieldScope

敏感字段控制接口，用于保护如密码、工资等敏感数据。

```csharp
public interface IFieldScope
{
    /// <summary>获取敏感字段列表</summary>
    String[] GetSensitiveFields();

    /// <summary>判断指定用户是否可以查看敏感字段</summary>
    Boolean CanViewSensitiveFields(Int32 userId);
}
```

**使用示例**（User 类的实现）：

```csharp
public partial class User : Entity<User>, IFieldScope
{
    String[] IFieldScope.GetSensitiveFields() => ["Password"];
    Boolean IFieldScope.CanViewSensitiveFields(Int32 userId) => userId == ID;
}
```

---

## 上下文管理

### DataScopeContext

数据权限上下文，存储当前用户的数据权限信息。

```csharp
public class DataScopeContext
{
    /// <summary>用户编号</summary>
    public Int32 UserId { get; set; }

    /// <summary>用户所属部门编号</summary>
    public Int32 DepartmentId { get; set; }

    /// <summary>数据范围</summary>
    public DataScopes DataScope { get; set; }

    /// <summary>可访问的部门编号列表。null 表示不限制</summary>
    public Int32[]? AccessibleDepartmentIds { get; set; }

    /// <summary>是否不受数据权限约束</summary>
    public Boolean IsSystem => DataScope == DataScopes.全部;

    /// <summary>是否可以查看敏感字段</summary>
    public Boolean ViewSensitive { get; set; }

    /// <summary>当前菜单编号。用于菜单级数据权限</summary>
    public Int32 MenuId { get; set; }
    
    /// <summary>当前数据权限上下文（线程/异步安全）</summary>
    public static DataScopeContext? Current { get; set; }
}
```

### 创建上下文

推荐使用 `DataScopeContext.Create` 从用户对象创建：

```csharp
// 从用户创建上下文
var ctx = DataScopeContext.Create(user);

// 也可以指定菜单，实现菜单级数据权限
var ctx = DataScopeContext.Create(user, menuId: 100);
```

**Create 方法的处理逻辑**：

1. 获取用户的所有角色
2. 如果任一角色是系统角色（IsSystem=true），数据范围设为"全部"
3. 否则，取所有角色中数据范围的最大权限（数值最小）
4. 敏感字段权限：任一角色有权即可
5. 计算可访问的部门列表并缓存

### 多角色权限合并

当用户拥有多个角色时，取最大权限（数值最小的 DataScope）：

```csharp
// 假设用户有两个角色：
// 角色A：DataScope = 仅本人 (3)
// 角色B：DataScope = 本部门及下级 (1)

// 最终权限 = Min(3, 1) = 本部门及下级
```

### 缓存管理

可访问部门列表会被缓存，角色变更后需清除：

```csharp
// 清除指定用户的缓存
DataScopeContext.ClearCache(userId);

// 清除所有缓存
DataScopeContext.ClearCache(0);
```

### 线程隔离

`DataScopeContext.Current` 使用 `AsyncLocal<T>` 存储，自动支持异步/多线程隔离：

```csharp
// 主线程设置
DataScopeContext.Current = ctx1;

await Task.Run(() =>
{
    // 子任务自动继承主线程的上下文
    var ctx = DataScopeContext.Current; // ctx1
    
    // 也可以设置不同的上下文，不影响主线程
    DataScopeContext.Current = ctx2;
});


// 主线程仍然是 ctx1
```

---

## 数据过滤

### 自动查询过滤（推荐）

注册 `DataScopeInterceptor` 后，**所有查询方法会自动应用数据权限过滤**，无需手动调用：

```csharp
static Order()
{
    // 注册数据权限拦截器后，查询自动过滤
    Meta.Interceptors.Add<DataScopeInterceptor>();
}


public static IList<Order> Search(String key, PageParameter page)
{
    var exp = new WhereExpression();
    if (!key.IsNullOrEmpty()) exp &= _.Name.Contains(key);
    
    // 无需调用 ApplyDataScope，自动过滤！
    return FindAll(exp, page);
}
```

**自动过滤覆盖的方法**：
- `FindAll` - 列表查询（同步/异步）
- `FindCount` - 计数查询（同步/异步）
- `Find` / `FindUnique` - 单条查询
- `FindSQL` - SQL 构建
- `FindAllWithCache` - 缓存查询（自动过滤）
- `FindByKeyWithCache` - 按主键查缓存
- `FindBySlaveWithCache` - 按从键查缓存

**绕过自动过滤的方式**：
```csharp
// 方式1：临时置空上下文
DataScopeContext.Current = null;
var allData = Order.FindAll();

// 方式2：直接访问缓存底层（不经过过滤）
var allCached = Meta.Session.Cache.Entities;
```

### 手动应用过滤（兼容保留）

`ApplyDataScope` 扩展方法仍然保留，用于需要精细控制的场景：

```csharp
public static IList<Order> Search(String key, PageParameter page)
{
    var exp = new WhereExpression();
    if (!key.IsNullOrEmpty()) exp &= _.Name.Contains(key);
    
    // 手动应用数据权限过滤（如果模块已自动过滤，此处会重复添加条件）
    exp = exp.ApplyDataScope<Order>();
    
    return FindAll(exp, page);
}
```

### 同时应用租户和数据权限

使用 `ApplyScope` 同时应用租户过滤和数据权限过滤：

```csharp
// 手动应用租户过滤 + 数据权限过滤
exp = exp.ApplyScope<Order>();

// 等价于
exp = exp.ApplyTenant<Order>();       // 租户过滤
exp = exp.ApplyDataScope<Order>();    // 数据权限过滤
```

### 手动获取过滤表达式

```csharp
// 获取 IDataScope 实体的过滤表达式
var filter = DataScopeHelper.GetFilter<Order>();

// 获取 IUserScope 实体的过滤表达式
var filter = DataScopeHelper.GetUserScopeFilter<Note>();

// 获取 IDepartmentScope 实体的过滤表达式
var filter = DataScopeHelper.GetDepartmentScopeFilter<Announcement>();
```

### 过滤逻辑

| 数据范围 | IDataScope | IUserScope | IDepartmentScope |
|---------|------------|------------|------------------|
| 全部 | 不过滤 | 不过滤 | 不过滤 |
| 仅本人 | UserId=当前用户 | UserId=当前用户 | DepartmentId=当前部门 |
| 本部门 | DepartmentId IN 可访问部门 | UserId=当前用户 | DepartmentId IN 可访问部门 |
| 本部门及下级 | DepartmentId IN 可访问部门 | UserId=当前用户 | DepartmentId IN 可访问部门 |
| 自定义 | DepartmentId IN 可访问部门 | UserId=当前用户 | DepartmentId IN 可访问部门 |

---

## 缓存查询

### 带过滤的缓存查询

```csharp
// 实体缓存查询（自动过滤）
var list = Order.FindAllWithCache();

// 按主键查单对象缓存（自动过滤）
var order = Order.FindByKeyWithCache(id);

// 按从键查单对象缓存（自动过滤）
var user = User.FindBySlaveWithCache("admin");
```

### 不带过滤的缓存访问

如果需要绕过数据权限直接访问缓存（例如后台任务），可以直接访问底层：

```csharp
// 直接访问实体缓存（不过滤）
var allEntities = Meta.Session.Cache.Entities;

// 直接访问单对象缓存（不过滤）
var entity = Meta.SingleCache[key];
```

---

## 增删改校验

### DataScopeInterceptor

注册 `DataScopeInterceptor` 后，增删改操作会自动进行数据权限校验：

```csharp
static Order()
{
    Meta.Interceptors.Add<DataScopeInterceptor>();
}
```

### 新增校验

1. 如果 UserId/DepartmentId 为 0，自动设置为当前用户/部门
2. 如果指定了 UserId/DepartmentId，检查是否有权为该用户/部门创建数据
3. 系统角色（DataScope=全部）可创建任意数据

```csharp
var order = new Order();
// order.UserId 和 order.DepartmentId 会自动设置
order.Save();

// 或者手动指定
var order = new Order { UserId = 100, DepartmentId = 200 };
// 如果当前用户无权为 UserId=100 创建数据，会抛出异常
order.Save();
```

### 修改校验

1. 如果没有脏数据，跳过校验
2. 检查当前用户是否有权修改该数据
3. 系统角色可修改任意数据

### 删除校验

1. 检查当前用户是否有权删除该数据
2. 系统角色可删除任意数据

### 手动校验

使用 `DataScopeHelper.CanAccess` 方法：

```csharp
// 校验 IDataScope 实体
var canAccess = DataScopeHelper.CanAccess(order);

// 校验 IUserScope 实体
var canAccess = DataScopeHelper.CanAccess((IUserScope)note);

// 校验 IDepartmentScope 实体
var canAccess = DataScopeHelper.CanAccess((IDepartmentScope)announcement);
```

---


## 敏感字段遮蔽

### 单个实体遮蔽

```csharp
// 实体实现 IFieldScope 接口
var user = User.FindByID(100);

// 遮蔽敏感字段
user.MaskSensitiveFields();

// 此时 user.Password 变为 "***"
```

### 批量遮蔽

```csharp
var list = User.Search(key, page);

// 批量遮蔽
FieldScopeHelper.MaskSensitiveFields(list);
```

### 遮蔽规则

1. 优先使用 `DataScopeContext.Current.ViewSensitive` 判断
2. 其次检查是否是本人数据（UserId == 当前用户）
3. 如果都不满足，遮蔽敏感字段

### 自定义遮蔽值

```csharp
// 使用自定义遮蔽值
user.MaskSensitiveFields(maskValue: "******");
```

---

## 高级用法

### 菜单级数据权限

某些菜单需要特殊的数据权限，可以在菜单上配置 DataScope：

```csharp
// 设置当前菜单
var ctx = DataScopeContext.Create(user, menuId: 100);

// 或者动态设置
DataScopeContext.Current?.SetMenu(menuId);
```

菜单级数据权限会覆盖角色默认值。

### 临时切换数据范围

```csharp
var originalCtx = DataScopeContext.Current;
try
{
    // 临时使用全部权限
    DataScopeContext.Current = new DataScopeContext
    {
        UserId = originalCtx?.UserId ?? 0,
        DataScope = DataScopes.全部
    };
    
    // 执行需要全部权限的操作
    var allOrders = Order.FindAll();
}
finally
{
    DataScopeContext.Current = originalCtx;
}
```

### 自定义部门层级

`GetDepartmentAndChildren` 方法获取部门及其所有下级：

```csharp
// 获取部门 100 及其所有下级的 ID 列表
var deptIds = DataScopeHelper.GetDepartmentAndChildren(100);
```

### 与租户隔离配合

数据权限通常与租户隔离配合使用：

```csharp
public static IList<Order> Search(PageParameter page)
{
    var exp = new WhereExpression();
    
    // 同时应用租户隔离和数据权限
    exp = exp.ApplyScope<Order>();
    
    return FindAll(exp, page);
}
```

---

## 最佳实践

### 1. 合理选择接口

```csharp
// ? 不推荐：个人数据使用完整 IDataScope
public class UserNote : IDataScope { }

// ? 推荐：个人数据使用 IUserScope
public class UserNote : IUserScope { }
```

### 2. 在 Search 方法中统一应用

```csharp
// ? 推荐：在 Search 方法中统一应用数据权限
public static IList<Order> Search(String key, PageParameter page)
{
    var exp = new WhereExpression();
    // ... 其他条件
    
    exp = exp.ApplyDataScope<Order>();  // 统一在这里应用
    
    return FindAll(exp, page);
}
```

### 3. 控制器层设置上下文

```csharp
// ? 推荐：在中间件或过滤器中统一设置
public class DataScopeFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        var user = ManageProvider.User as IUser;
        DataScopeContext.Current = DataScopeContext.Create(user);
    }
    
    public void OnActionExecuted(ActionExecutedContext context)
    {
        DataScopeContext.Current = null;
    }
}
```

### 4. 避免在循环中重复计算

```csharp
// ? 不推荐：循环中重复调用
foreach (var item in items)
{
    if (DataScopeHelper.CanAccess(item)) { }
}

// ? 推荐：提前获取上下文
var ctx = DataScopeContext.Current;
foreach (var item in items)
{
    if (DataScopeHelper.CanAccess(item, ctx)) { }
}
```

### 5. 合理使用缓存

```csharp
// 角色变更后清除缓存
public void UpdateUserRole(Int32 userId, Int32 roleId)
{
    var user = User.FindByID(userId);
    user.RoleID = roleId;
    user.Save();
    
    // 清除该用户的数据权限缓存
    DataScopeContext.ClearCache(userId);
}
```

---

## 常见问题

### Q1: 数据权限不生效？

**检查清单**：
1. 实体类是否实现了正确的接口（IUserScope/IDepartmentScope/IDataScope）
2. 是否注册了 `DataScopeInterceptor`
3. 是否设置了 `DataScopeContext.Current`
4. 查询是否调用了 `ApplyDataScope`
5. 用户角色的 DataScope 是否配置正确

### Q2: 系统管理员如何绕过数据权限？

角色的 `IsSystem = true` 或 `DataScope = 全部` 时不受数据权限约束：

```csharp
// 方式1：角色标记为系统角色
role.IsSystem = true;

// 方式2：角色数据范围设为全部
role.DataScope = DataScopes.全部;
```

### Q3: 如何支持自定义字段名？

实现 `IDataScopeFieldProvider` 接口：

```csharp
public partial class Order : IDataScope, IDataScopeFieldProvider
{
    public FieldItem? GetUserField() => _.CreatorId;
    public FieldItem? GetDepartmentField() => _.OrgId;
    public FieldItem? GetTenantField() => null;
}
```

### Q4: 多角色权限如何计算？

取所有角色中数据范围的最大权限（DataScope 数值最小的）：

```
全部(0) > 本部门及下级(1) > 本部门(2) > 仅本人(3) > 自定义(4)
```

### Q5: 如何临时禁用数据权限？

```csharp
// 方式1：临时清除上下文
var ctx = DataScopeContext.Current;
DataScopeContext.Current = null;
try
{
    // 不受数据权限约束的操作
}
finally
{
    DataScopeContext.Current = ctx;
}

// 方式2：使用系统权限上下文
DataScopeContext.Current = new DataScopeContext { DataScope = DataScopes.全部 };
```

### Q6: 数据权限会影响 FindByID 吗？

不会。`FindByID` 等单条查询方法默认不应用数据权限过滤，需要手动校验：

```csharp
var order = Order.FindByID(id);
if (order != null && !DataScopeHelper.CanAccess(order))
{
    throw new UnauthorizedAccessException("无权访问此数据");
}
```

---

## 附录

### 相关类型

| 类型 | 命名空间 | 说明 |
|------|----------|------|
| `DataScopes` | XCode.Membership | 数据范围枚举 |
| `IUserScope` | XCode.Membership | 用户范围接口 |
| `IDepartmentScope` | XCode.Membership | 部门范围接口 |
| `IDataScope` | XCode.Membership | 完整数据权限接口 |
| `IDataScopeFieldProvider` | XCode.Membership | 自定义字段提供者接口 |
| `IFieldScope` | XCode.Membership | 敏感字段接口 |
| `DataScopeContext` | XCode.Membership | 数据权限上下文 |
| `DataScopeModule` | XCode.Membership | 数据权限实体模块 |
| `DataScopeHelper` | XCode.Membership | 数据权限辅助类 |
| `FieldScopeHelper` | XCode.Membership | 敏感字段辅助类 |

### 参考资料

- [XCode Membership 权限管理模块](权限管理.md)
- [XCode ORM 官方文档](https://newlifex.com/xcode)
- [GitHub 仓库](https://github.com/NewLifeX/NewLife.XCode)
